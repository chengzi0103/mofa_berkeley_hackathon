from mofa.kernel.utils.log import write_agent_log
from mofa.run.run_agent import run_dspy_agent, run_crewai_agent

# inputs = {'model_api_key': '    ', 'model_name': 'gpt-3.5-turbo', 'model_max_tokens': 2048, 'role': 'You are a task evaluation assistant. Based on the question and answer, check if the task meets the standards of completeness, accuracy, relevance, clarity, and user satisfaction.', 'answer': '"Yes" or "No" only.\n', 'task': None, 'proxy_url': 'http://192.168.0.75:10809', 'agent_type': 'reasoner', 'max_iterations': 2, 'log_path': './data/output/log/paper_dataflow.md', 'log_type': 'markdown', 'log_step_name': 'evaluation_agent', 'context': '**Answer:**\n\nDesigning an AIOS (Artificial Intelligence Operating System) involves several critical steps to ensure it is efficient, reliable, and up-to-date with current trends. Below is a detailed guide on how to design an AIOS, incorporating examples, case studies, and user feedback to enhance clarity and relevance.\n\n### Step-by-Step Instructions on Designing an AIOS\n\n1. **Define the Objectives and Scope**\n   - **Objective**: Determine the primary purpose of the AIOS. Is it for managing LLM (Large Language Model) agents, coordinating AI-related activities, or something else?\n   - **Scope**: Outline the functionalities and limitations. For instance, will it support multiple AI models, handle large datasets, or provide real-time processing?\n\n2. **Architectural Design**\n   - **Modules**: Identify and design the core modules of the AIOS. Common modules include:\n     - **Agent Scheduler**: Manages and prioritizes agent requests.\n     - **Context Manager**: Handles context windows for LLMs.\n     - **Memory Manager**: Optimizes memory usage.\n     - **Storage Manager**: Manages data storage efficiently.\n     - **Tool Manager**: Integrates various tools required by the agents.\n     - **Access Manager**: Ensures security and privacy controls.\n   - **Example**: In a case study, a Docker Compose descriptor for a newsfeed system was transformed into a system architectural diagram using a similar modular approach.\n\n3. **Develop Advanced Algorithms**\n   - **Scheduling Algorithms**: Implement advanced scheduling algorithms to optimize task management.\n   - **Context Management Techniques**: Develop techniques to efficiently manage context windows, ensuring relevant information is retained and irrelevant data is discarded.\n   - **Memory and Storage Optimization**: Use techniques like data compression and efficient indexing to optimize memory and storage usage.\n\n4. **Implement Security and Privacy Measures**\n   - **Access Control**: Implement robust access control mechanisms to protect sensitive data.\n   - **Privacy Enhancements**: Ensure that the AIOS complies with privacy regulations and best practices.\n\n5. **Integration and Testing**\n   - **Integration**: Integrate the AIOS with existing systems and tools.\n   - **Testing**: Conduct thorough testing to identify and fix bugs. Use both unit tests and integration tests to ensure the system works as expected.\n   - **Case Study**: A study on fault-tolerant system architectures for automated driving systems highlighted the importance of testing different configurations to identify the most reliable setup.\n\n6. **User Feedback and Iteration**\n   - **Collect Feedback**: Gather feedback from users to understand their needs and pain points.\n   - **Iterate**: Use the feedback to make iterative improvements to the AIOS.\n   - **Example**: A survey among software developers was conducted to list relevant guidelines for architectural diagram quality, which helped in refining the system.\n\n7. **Documentation and Training**\n   - **Documentation**: Provide comprehensive documentation to help users understand and use the AIOS effectively.\n   - **Training**: Offer training sessions or tutorials to onboard new users.\n\n### Practical Application and Case Studies\n\n- **Automated Customer Service**: AIOS can be used to manage LLMs that handle customer queries, improving response times and accuracy.\n- **Digital Assistants**: Enhance the performance of digital assistants by optimizing resource utilization and ensuring privacy.\n- **Autonomous Vehicles**: Implement fault-tolerant architectures to ensure the safe operation of autonomous vehicles in real-world conditions.\n\n### Visuals and Clear Language\n\n- **Flowcharts**: Use flowcharts to illustrate the architecture and data flow within the AIOS.\n- **Diagrams**: Provide diagrams of the modules and their interactions.\n- **Screenshots**: Include screenshots of the AIOS in action to give users a visual understanding of its functionalities.\n\n### Conclusion\n\nDesigning an AIOS requires careful planning, advanced algorithm development, robust security measures, and continuous iteration based on user feedback. By following these steps and incorporating the latest trends and technologies, you can create an efficient and reliable AIOS that meets the needs of its users.\n\n---\n\nThis guide provides a comprehensive approach to designing an AIOS, ensuring accuracy, relevance, and clarity. By following these steps and considering user feedback, you can develop a high-quality AIOS that enhances user satisfaction and meets current design trends.'}
# dora_result  = {'task': 'How to design an AIOS? ', 'suggestion': '**Answer:**\n\nDesigning an AIOS (Artificial Intelligence Operating System) involves several critical steps to ensure it is efficient, reliable, and up-to-date with current trends. Below is a detailed guide on how to design an AIOS, incorporating examples, case studies, and user feedback to enhance clarity and relevance.\n\n### Step-by-Step Instructions on Designing an AIOS\n\n1. **Define the Objectives and Scope**\n   - **Objective**: Determine the primary purpose of the AIOS. Is it for managing LLM (Large Language Model) agents, coordinating AI-related activities, or something else?\n   - **Scope**: Outline the functionalities and limitations. For instance, will it support multiple AI models, handle large datasets, or provide real-time processing?\n\n2. **Architectural Design**\n   - **Modules**: Identify and design the core modules of the AIOS. Common modules include:\n     - **Agent Scheduler**: Manages and prioritizes agent requests.\n     - **Context Manager**: Handles context windows for LLMs.\n     - **Memory Manager**: Optimizes memory usage.\n     - **Storage Manager**: Manages data storage efficiently.\n     - **Tool Manager**: Integrates various tools required by the agents.\n     - **Access Manager**: Ensures security and privacy controls.\n   - **Example**: In a case study, a Docker Compose descriptor for a newsfeed system was transformed into a system architectural diagram using a similar modular approach.\n\n3. **Develop Advanced Algorithms**\n   - **Scheduling Algorithms**: Implement advanced scheduling algorithms to optimize task management.\n   - **Context Management Techniques**: Develop techniques to efficiently manage context windows, ensuring relevant information is retained and irrelevant data is discarded.\n   - **Memory and Storage Optimization**: Use techniques like data compression and efficient indexing to optimize memory and storage usage.\n\n4. **Implement Security and Privacy Measures**\n   - **Access Control**: Implement robust access control mechanisms to protect sensitive data.\n   - **Privacy Enhancements**: Ensure that the AIOS complies with privacy regulations and best practices.\n\n5. **Integration and Testing**\n   - **Integration**: Integrate the AIOS with existing systems and tools.\n   - **Testing**: Conduct thorough testing to identify and fix bugs. Use both unit tests and integration tests to ensure the system works as expected.\n   - **Case Study**: A study on fault-tolerant system architectures for automated driving systems highlighted the importance of testing different configurations to identify the most reliable setup.\n\n6. **User Feedback and Iteration**\n   - **Collect Feedback**: Gather feedback from users to understand their needs and pain points.\n   - **Iterate**: Use the feedback to make iterative improvements to the AIOS.\n   - **Example**: A survey among software developers was conducted to list relevant guidelines for architectural diagram quality, which helped in refining the system.\n\n7. **Documentation and Training**\n   - **Documentation**: Provide comprehensive documentation to help users understand and use the AIOS effectively.\n   - **Training**: Offer training sessions or tutorials to onboard new users.\n\n### Practical Application and Case Studies\n\n- **Automated Customer Service**: AIOS can be used to manage LLMs that handle customer queries, improving response times and accuracy.\n- **Digital Assistants**: Enhance the performance of digital assistants by optimizing resource utilization and ensuring privacy.\n- **Autonomous Vehicles**: Implement fault-tolerant architectures to ensure the safe operation of autonomous vehicles in real-world conditions.\n\n### Visuals and Clear Language\n\n- **Flowcharts**: Use flowcharts to illustrate the architecture and data flow within the AIOS.\n- **Diagrams**: Provide diagrams of the modules and their interactions.\n- **Screenshots**: Include screenshots of the AIOS in action to give users a visual understanding of its functionalities.\n\n### Conclusion\n\nDesigning an AIOS requires careful planning, advanced algorithm development, robust security measures, and continuous iteration based on user feedback. By following these steps and incorporating the latest trends and technologies, you can create an efficient and reliable AIOS that meets the needs of its users.\n\n---\n\nThis guide provides a comprehensive approach to designing an AIOS, ensuring accuracy, relevance, and clarity. By following these steps and considering user feedback, you can develop a high-quality AIOS that enhances user satisfaction and meets current design trends.', 'context': '**Answer:**\n\nDesigning an AIOS (Artificial Intelligence Operating System) involves several critical steps to ensure it is efficient, reliable, and up-to-date with current trends. Below is a detailed guide on how to design an AIOS, incorporating examples, case studies, and user feedback to enhance clarity and relevance.\n\n### Step-by-Step Instructions on Designing an AIOS\n\n1. **Define the Objectives and Scope**\n   - **Objective**: Determine the primary purpose of the AIOS. Is it for managing LLM (Large Language Model) agents, coordinating AI-related activities, or something else?\n   - **Scope**: Outline the functionalities and limitations. For instance, will it support multiple AI models, handle large datasets, or provide real-time processing?\n\n2. **Architectural Design**\n   - **Modules**: Identify and design the core modules of the AIOS. Common modules include:\n     - **Agent Scheduler**: Manages and prioritizes agent requests.\n     - **Context Manager**: Handles context windows for LLMs.\n     - **Memory Manager**: Optimizes memory usage.\n     - **Storage Manager**: Manages data storage efficiently.\n     - **Tool Manager**: Integrates various tools required by the agents.\n     - **Access Manager**: Ensures security and privacy controls.\n   - **Example**: In a case study, a Docker Compose descriptor for a newsfeed system was transformed into a system architectural diagram using a similar modular approach.\n\n3. **Develop Advanced Algorithms**\n   - **Scheduling Algorithms**: Implement advanced scheduling algorithms to optimize task management.\n   - **Context Management Techniques**: Develop techniques to efficiently manage context windows, ensuring relevant information is retained and irrelevant data is discarded.\n   - **Memory and Storage Optimization**: Use techniques like data compression and efficient indexing to optimize memory and storage usage.\n\n4. **Implement Security and Privacy Measures**\n   - **Access Control**: Implement robust access control mechanisms to protect sensitive data.\n   - **Privacy Enhancements**: Ensure that the AIOS complies with privacy regulations and best practices.\n\n5. **Integration and Testing**\n   - **Integration**: Integrate the AIOS with existing systems and tools.\n   - **Testing**: Conduct thorough testing to identify and fix bugs. Use both unit tests and integration tests to ensure the system works as expected.\n   - **Case Study**: A study on fault-tolerant system architectures for automated driving systems highlighted the importance of testing different configurations to identify the most reliable setup.\n\n6. **User Feedback and Iteration**\n   - **Collect Feedback**: Gather feedback from users to understand their needs and pain points.\n   - **Iterate**: Use the feedback to make iterative improvements to the AIOS.\n   - **Example**: A survey among software developers was conducted to list relevant guidelines for architectural diagram quality, which helped in refining the system.\n\n7. **Documentation and Training**\n   - **Documentation**: Provide comprehensive documentation to help users understand and use the AIOS effectively.\n   - **Training**: Offer training sessions or tutorials to onboard new users.\n\n### Practical Application and Case Studies\n\n- **Automated Customer Service**: AIOS can be used to manage LLMs that handle customer queries, improving response times and accuracy.\n- **Digital Assistants**: Enhance the performance of digital assistants by optimizing resource utilization and ensuring privacy.\n- **Autonomous Vehicles**: Implement fault-tolerant architectures to ensure the safe operation of autonomous vehicles in real-world conditions.\n\n### Visuals and Clear Language\n\n- **Flowcharts**: Use flowcharts to illustrate the architecture and data flow within the AIOS.\n- **Diagrams**: Provide diagrams of the modules and their interactions.\n- **Screenshots**: Include screenshots of the AIOS in action to give users a visual understanding of its functionalities.\n\n### Conclusion\n\nDesigning an AIOS requires careful planning, advanced algorithm development, robust security measures, and continuous iteration based on user feedback. By following these steps and incorporating the latest trends and technologies, you can create an efficient and reliable AIOS that meets the needs of its users.\n\n---\n\nThis guide provides a comprehensive approach to designing an AIOS, ensuring accuracy, relevance, and clarity. By following these steps and considering user feedback, you can develop a high-quality AIOS that enhances user satisfaction and meets current design trends.', 'local_iterations': 1, 'rag_data': [{'./data/output/arxiv_papers/2111.09762v1.pdf': "Answer:\n\n1. **Creation Time of the Paper:**\n   The creation time of the paper is not explicitly mentioned in the provided data. However, references within the paper suggest it was written after 2014, as it cites works published up to that year.\n\n2. **Main Author of the Paper:**\n   The main authors of the paper are V. Dorofeev and P. Trokhimchuck. V. Dorofeev is affiliated with the Scientific Institute of System Analysis of the Russian Academy of Sciences, Moscow, Russia, and P. Trokhimchuck is affiliated with Lesya Ukrainka Volyn National University, Lutsk, Ukraine.\n\n3. **Research Methods or Techniques Used in the Paper:**\n   The paper employs polymetric analysis (PA) and hybrid theory of systems (HTS) as its primary research methods. PA is described as a universal theory of synthesis that involves mathematical, methodological, and scientific elements. It includes procedures of measurement, mathematical operations, and transformations. HTS is used for classifying systems of calculation based on criteria of reciprocity and simplicity, and it involves analyzing systems with respect to their complexity.\n\n4. **Summary of the Abstract Content of the Paper:**\n   The paper discusses the application of Polymetric Analysis (PA) to resolve problems in artificial intelligence, specifically focusing on the hybrid super intelligence system by N. Moiseev. It highlights the bond between PA and hybrid super intelligence, showing that PA is a more general system that can unify the main principles of Moiseev's concept. The paper also addresses the complexity of researched information and the need for a universal synthetic theory, which PA aims to provide. The abstract emphasizes the criteria of reciprocity and simplicity as fundamental principles of PA.\n\n5. **Practical Application Value of the Research Results in the Paper:**\n   The practical application value of the research lies in its potential to optimize informative calculations and enhance the efficiency of artificial intelligence systems. The principles of PA, such as the criterion of reciprocity and the principle of optimal informative calculations, can be applied to various fields, including environmental monitoring, sustainable agriculture, and the development of strong hybrid intelligence systems. The theory provides a framework for creating open systems with variable hierarchies, which can be used to model and predict real-world scenarios, such as the impact of external influences on the environment or the spread of diseases like COVID-19."}, {'./data/output/arxiv_papers/2210.04040v1.pdf': 'Answer:\n\n1. **Creation Time of the Paper**: The paper was created in 2020.\n\n2. **Main Author of the Paper**: The main authors of the paper are T.M. Julitz, A. Tordeux, and M. Löwer.\n\n3. **Research Methods or Techniques Used in the Paper**:\n   - The paper employs Markovian analysis to determine the reliability of different system architectures.\n   - It uses numerical analysis to evaluate the survival probability of various majority redundant systems of sensors and MCUs.\n   - The research involves comparing different sensor and MCU architectures to identify the most suitable configuration for fault-tolerant functions.\n   - The study also includes the use of error correction algorithms and repair rate considerations for availability analysis.\n\n4. **Summary of the Abstract Content of the Paper**:\n   - The paper discusses the development of fault-tolerant system architectures for automated driving systems, focusing on self-diagnosis and reliability.\n   - It highlights the importance of majority redundancy in achieving high reliability and fault tolerance.\n   - The study compares different system configurations, including series and parallel systems, and identifies the most suitable architectures for fault-tolerant operations.\n   - The research combines aspects of self-diagnosis, reliability, availability, reconstruction, and fault recovery to provide a comprehensive analysis of fault-tolerant systems.\n\n5. **Practical Application Value of the Research Results**:\n   - The research results have significant practical application value in the development of automated and autonomous vehicle systems.\n   - The findings can be used to design more reliable and fault-tolerant system architectures, which are crucial for the safe operation of autonomous vehicles in real-world traffic conditions.\n   - The study provides insights into the selection of suitable majority redundancy configurations, which can enhance the reliability and robustness of automated driving systems.\n   - The research also offers valuable guidelines for future developments in fault-tolerant system design, contributing to the advancement of autonomous vehicle technology.'}, {'./data/output/arxiv_papers/2210.11910v1.pdf': "Answer:\n\n1. **Creation Time of the Paper**: The exact creation time of the paper is not explicitly mentioned in the provided data.\n\n2. **Main Author of the Paper**: The main author of the paper is not explicitly mentioned in the provided data. However, the references include multiple authors such as S. O. B. Amor, M. Ali, F. Gargouri, M. Artac, T. Borovssak, E. D. Nitto, M. Guerriero, and D. A. Tamburri, among others.\n\n3. **Research Methods or Techniques Used in the Paper**:\n   - **Survey Research**: The paper conducted a survey among software developers to list relevant guidelines for architectural diagram quality.\n   - **Case Study**: A case study was conducted where a Docker Compose descriptor for a newsfeed system was transformed into a system architectural diagram using the proposed approach.\n   - **Cosine Similarity Metric**: Used to calculate the similarity score between participants' texts and the original text.\n   - **Likert Scale**: Used to interpret data from participants' responses.\n\n4. **Summary of the Abstract Content of the Paper**:\n   The paper addresses the challenge of creating consistent architectural diagrams for distributed systems. It proposes using system descriptors, which are scripts for automating, standardizing, and managing infrastructure, to improve the consistency of these diagrams. The paper includes a survey on the problems with architectural diagrams in the software industry and develops guidelines for creating consistent diagrams. A case study is presented where a Docker Compose descriptor is transformed into an architectural diagram, demonstrating the potential of the proposed approach.\n\n5. **Practical Application Value of the Research Results in the Paper**:\n   - **Improved Consistency**: The approach aims to improve the consistency of architectural diagrams, making them more reliable and easier to understand.\n   - **Synchronization with System Evolution**: Architectural diagrams created from system descriptors can remain synchronized with the evolution of the system, reducing inconsistency errors.\n   - **Guidelines for Practitioners**: The guidelines developed from the survey can help practitioners understand what qualities to expect in an architectural diagram and improve their diagramming practices.\n   - **Potential for Automation**: The approach suggests that system descriptors can be used to automate the creation of architectural diagrams, potentially saving time and reducing manual errors."}, {'./data/output/arxiv_papers/2305.07035v1.pdf': 'Answer:\n\n1. **Creation Time of the Paper**: The paper was created on May 10, 2023.\n\n2. **Main Author of the Paper**: The main authors of the paper are Pavel Naumov from the University of Southampton, United Kingdom, and Oliver Orejola from Tulane University, United States.\n\n3. **Research Methods or Techniques Used in the Paper**: The paper proposes a formal semantics of clandestine operations and introduces a sound and complete logical system that describes the interplay between the distributed knowledge modality and a modality capturing coalition power to conduct clandestine operations. The research involves the study of games in which coalitions can engage in concealed operations, using logical systems and semantics to model these behaviors.\n\n4. **Summary of the Abstract Content of the Paper**: The paper defines the semantics of clandestine operations in terms of a class of asynchronous games called clandestine games. It discusses the interplay between knowledge and actions and explains why existing coalition power modalities do not capture the properties of clandestine operations. The paper proposes a sound and complete logical system for reasoning about coalition power to conduct clandestine operations, detailing the syntax and semantics of the system, and discussing the most non-trivial axiom of the system.\n\n5. **Practical Application Value of the Research Results in the Paper**: The practical application value of the research results lies in providing a formal framework to understand and model clandestine operations, which can be applied in various fields such as military strategy, intelligence operations, and cybersecurity. The logical system proposed can help in designing strategies that involve concealed actions and understanding the implications of such operations in a multi-agent environment.'}, {'./data/output/arxiv_papers/2403.16971v2.pdf': 'Answer:\n\n1. **Creation Time of the Paper**: The paper was created in 2023.\n\n2. **Main Author of the Paper**: The main author of the paper is not explicitly mentioned in the provided data. However, the authors listed include Yingqiang Ge, Yujie Ren, Wenyue Hua, Shuyuan Xu, Juntao Tan, and Yongfeng Zhang.\n\n3. **Research Methods or Techniques Used in the Paper**: The paper discusses the design and implementation of an LLM agent operating system (AIOS). It includes various modules such as the Agent Scheduler, Context Manager, Memory Manager, Storage Manager, Tool Manager, and Access Manager. The paper also explores advanced scheduling algorithms, context management techniques, memory and storage architecture optimization, and safety and privacy enhancements.\n\n4. **Summary of the Abstract Content of the Paper**: The paper proposes AIOS, an LLM agent operating system designed to manage and coordinate LLM-related activities. It addresses challenges such as scheduling and prioritizing agent requests, managing context windows, and ensuring efficient memory and storage management. The AIOS system includes modules for agent scheduling, context management, memory management, storage management, tool management, and access control. The paper also discusses the potential for future research in advanced scheduling algorithms, context management efficiency, memory and storage optimization, and safety and privacy enhancements.\n\n5. **Practical Application Value of the Research Results in the Paper**: The practical application value of the research results lies in the development of a robust system for managing LLM agents and their interactions. AIOS aims to optimize the utilization of LLM resources, improve the efficiency of response generation, and ensure stringent privacy and access control measures. This system can be applied in various domains where LLMs are used, such as digital assistants, automated customer service, and other AI-driven applications, enhancing their performance and reliability.'}, {'./data/output/arxiv_papers/2404.03044v1.pdf': "Answer:\n\n1. **Retrieve the creation time of the paper:**\n   The creation time of the paper is not explicitly mentioned in the provided data. However, references to the paper's content and related works suggest it was created around 2023-2024.\n\n2. **Who is the main author of the paper:**\n   The main author of the paper is Marcin P. Joachimiak, along with other contributors including Mark A. Miller, J. Harry Caufield, Ryan Ly, Nomi L. Harris, Andrew Tritt, Christopher J. Mungall, and Kristofer E. Bouchard.\n\n3. **What research methods or techniques were used in the paper:**\n   The paper utilized a variety of research methods and techniques, including:\n   - AI-assisted ontology development\n   - Ontology seeding, extension, maintenance, and updating using LLMs\n   - Use of the ROBOT ontology creation agent_link\n   - Ontology Access Kit (OAK) framework for annotating methods data\n   - Ontology Development Toolkit (ODK) for organizing and validating ontology content\n   - ELK reasoner for fast reasoning over the EL ontology profile\n   - Standard concept recognition techniques for accurate matching of AI concepts\n\n4. **Provide a summary of the abstract content of the paper:**\n   The Artificial Intelligence Ontology (AIO) is a systematization of AI concepts, methodologies, and their interrelations. Developed through manual curation and LLM assistance, AIO aims to address the evolving AI landscape by providing a comprehensive framework encompassing technical and ethical aspects of AI technologies. It is structured around six top-level branches: Networks, Layers, Functions, LLMs, Preprocessing, and Bias. The ontology supports modular composition of AI methods and facilitates understanding of deep learning architectures and ethical considerations. AIO's development utilized the Ontology Development Kit (ODK) and is dynamically updated through AI-driven curation support, ensuring relevance amidst rapid AI advancements. The ontology is open source and available on GitHub and BioPortal.\n\n5. **What is the practical application value of the research results in the paper:**\n   The practical application value of the research results includes:\n   - Enhanced model cards for better transparency and understanding of AI models\n   - Improved communication, collaboration, and sharing of results within the AI community\n   - Support for ongoing projects and integration into multiple use cases\n   - Facilitation of the annotation and comparison of AI models\n   - Standardization of AI terminology, aiding in the annotation of code repositories and academic papers\n   - Assistance for AI research newcomers in understanding publications and linking method code to descriptions and classifications\n   - Promotion of responsible AI development and deployment through standardized records and ethical considerations."}]}
# inputs['context'] = dora_result.get('context')
# local_iterations = dora_result.get('local_iterations', None)
# if local_iterations is not None:
#     max_iterations = inputs.get('max_iterations')
#     if local_iterations > max_iterations:
#         print('Task Result:  ',dora_result.get('context'))
#         log_result = {"7, " + inputs.get('log_step_name', "Step_one"): dora_result.get('context')}
#
#         write_agent_log(log_type=inputs.get('log_type', None),
#                         log_file_path=inputs.get('log_path', None),
#                         data=log_result)
#
#     else:
#         print(inputs)
#         if 'agents' not in inputs.keys():
#             inputs['task'] = dora_result['task']
#
#             result = run_dspy_agent(inputs=inputs)
#         else:
#             result = run_crewai_agent(crewai_config=inputs)
#         log_result = {"7, " + inputs.get('log_step_name', "Step_one"): result}
#
#         if 'Yes' in result or 'yes' in result:
#             print(f"In the {dora_result.get('local_iterations')} iteration result  : ", inputs['context'])
#             write_agent_log(log_type=inputs.get('log_type', None),
#                             log_file_path=inputs.get('log_path', None),
#                             data=log_result)
#
#         else:
#             inputs['local_iterations'] = local_iterations + 1
#             result = { 'context': dora_result.get('context'),'local_iterations':inputs['local_iterations'],'rag_data':dora_result['rag_data'],'task':dora_result['task']}
#             print(f"The {inputs['local_iterations']} iteration Result:  ",)
#             write_agent_log(log_type=inputs.get('log_type', None),
#                             log_file_path=inputs.get('log_path', None),
#                             data=log_result)
#
#
# writer_result  =   {'task': 'How to design an AIOS?', 'max_iterations': 1, 'context': "Question: How to design an AIOS?\n\nAnswer: \n\nDesigning an AI Operating System (AIOS) involves several key strategies and methodologies, as identified through the analysis of various academic papers. Here are the main approaches and ideas proposed by researchers:\n\n1. **Modular Architecture**:\n   - **Component-Based Design**: Implement a modular architecture where different components (e.g., data processing, model training, inference) are decoupled. This allows for flexibility and scalability in the system [2304.01597v1].\n   - **Microservices**: Use microservices to manage different functionalities independently, enabling easier updates and maintenance [2304.01597v1].\n\n2. **Integration of Advanced AI Techniques**:\n   - **Knowledge Graphs**: Integrate knowledge graphs to enhance the system's ability to understand and process complex queries by providing contextual information [2304.01597v1].\n   - **Self-Supervised Learning**: Employ self-supervised learning techniques to improve the system's ability to learn from large amounts of unlabeled data, enhancing its language understanding and generation capabilities [2304.01597v1].\n\n3. **User-Centric Design**:\n   - **Natural Language Interface**: Develop a natural language interface that allows users to interact with the AIOS using conversational language, making it more accessible and user-friendly [2304.01597v1].\n   - **Personalization**: Implement personalization features that adapt to individual user preferences and behaviors, providing a more tailored experience [2304.01597v1].\n\n4. **Security and Privacy**:\n   - **Data Encryption**: Ensure that all user data is encrypted both in transit and at rest to protect against unauthorized access [2304.01597v1].\n   - **Privacy-Preserving Techniques**: Use techniques such as differential privacy to ensure that the system can learn from user data without compromising individual privacy [2304.01597v1].\n\n5. **Scalability and Performance**:\n   - **Distributed Computing**: Utilize distributed computing frameworks to handle large-scale data processing and model training, ensuring that the system can scale efficiently [2304.01597v1].\n   - **Optimization Algorithms**: Implement optimization algorithms to improve the performance and efficiency of the AI models, reducing latency and resource consumption [2304.01597v1].\n\n6. **Continuous Learning and Adaptation**:\n   - **Online Learning**: Incorporate online learning mechanisms that allow the system to continuously learn and adapt from new data, ensuring that it remains up-to-date with the latest information [2304.01597v1].\n   - **Feedback Loops**: Establish feedback loops where user interactions and feedback are used to refine and improve the system over time [2304.01597v1].\n\nBy integrating these strategies, an AIOS can be designed to be flexible, scalable, user-friendly, and secure, while continuously improving its capabilities through advanced AI techniques and user feedback.", 'local_iterations': 1, 'rag_data': [{'./data/output/arxiv_papers/2403.16971v2.pdf': 'Answer:\n\n1. **Creation Time of the Paper**: The paper was created in 2023.\n\n2. **Main Author of the Paper**: The main author of the paper is Yingqiang Ge, along with co-authors Yujie Ren, Wenyue Hua, Shuyuan Xu, Juntao Tan, and Yongfeng Zhang.\n\n3. **Research Methods or Techniques Used in the Paper**: The paper does not explicitly mention specific research methods or techniques used. However, it discusses the design and implementation of AIOS, an LLM agent operating system, and various modules such as the Agent Scheduler, Context Manager, Memory Manager, Storage Manager, and Tool Manager.\n\n4. **Summary of the Abstract Content of the Paper**: The paper proposes AIOS, an LLM agent operating system designed to address the challenges of managing and coordinating LLM-related activities. It introduces a suite of modules within the LLM kernel, including the Agent Scheduler, Context Manager, Memory Manager, Storage Manager, and Tool Manager. These modules aim to optimize LLM utilization, manage context windows, provide short-term and long-term memory management, and enforce privacy and access control measures. The paper also discusses the potential for future research in advanced scheduling algorithms, context management techniques, memory and storage architecture optimization, and safety and privacy enhancements.\n\n5. **Practical Application Value of the Research Results in the Paper**: The practical application value of the research results lies in the development of a robust and efficient operating system for LLM agents. AIOS aims to enhance the management and coordination of LLM-related activities, optimize resource utilization, and ensure privacy and security. This can significantly improve the performance and reliability of LLM-based applications, making them more effective in various real-world scenarios such as virtual assistants, automated customer service, and other AI-driven tasks.'}, {'./data/output/arxiv_papers/2404.03044v1.pdf': "Answer:\n\n1. **Retrieve the creation time of the paper:**\n   The creation time of the paper is not explicitly mentioned in the provided data. However, references to the paper and related works suggest it was created around 2023-2024.\n\n2. **Who is the main author of the paper:**\n   The main author of the paper is Marcin P. Joachimiak, along with other contributors including Mark A. Miller, J. Harry Caufield, Ryan Ly, Nomi L. Harris, Andrew Tritt, Christopher J. Mungall, and Kristofer E. Bouchard.\n\n3. **What research methods or techniques were used in the paper:**\n   The research methods and techniques used in the paper include:\n   - AI-assisted ontology development\n   - Ontology seeding, extension, maintenance, and updating\n   - Use of the ROBOT ontology creation agent_link\n   - Few-shot learning examples\n   - Ontology Access Kit (OAK) framework for annotating methods data\n   - Use of the Ontology Development Toolkit (ODK) for organizing ontology content\n   - ELK reasoner for fast reasoning over the EL ontology profile\n   - Data-driven evaluation using the OAK framework and ROBOT statistics command\n   - MIRO guidelines for improving the ontology and manuscript\n\n4. **Provide a summary of the abstract content of the paper:**\n   The Artificial Intelligence Ontology (AIO) is a systematization of AI concepts, methodologies, and their interrelations. Developed through manual curation and LLM assistance, AIO aims to address the evolving AI landscape by providing a comprehensive framework encompassing technical and ethical aspects of AI technologies. It is structured around six top-level branches: Networks, Layers, Functions, LLMs, Preprocessing, and Bias. The ontology's development utilized the Ontology Development Kit (ODK) and is dynamically updated through AI-driven curation support. AIO's utility is demonstrated through the annotation of AI methods data in a catalog of AI research publications and integration into the BioPortal ontology resource. The ontology is open source and available on GitHub and BioPortal.\n\n5. **What is the practical application value of the research results in the paper:**\n   The practical application value of the research results includes:\n   - Enhanced model cards for improved transparency and understanding of AI models\n   - Standardized terminology and concepts for clearer communication and collaboration within the AI community\n   - Facilitation of the annotation and comparison of AI models\n   - Support for responsible AI development and deployment by ensuring clear understanding of AI model capabilities and limitations\n   - Broad applicability across AI research and development, enabling researchers to identify methods or publications referring to standardized AI terms\n   - Assistance for AI research newcomers in understanding publications and linking method code to descriptions and classifications\n   - Continuous updates and community contributions to keep the ontology relevant and up-to-date with advancements in AI."}]}
# inputs = {'model_api_key': '    ', 'model_name': 'gpt-3.5-turbo', 'model_max_tokens': 2048, 'role': 'You are a content evaluation assistant. Evaluate the content based on completeness, accuracy, relevance, clarity, and user satisfaction. Provide your own suggestions (keep suggestions simple, clear, and directional). Only include the suggestions in your response.', 'backstory': 'Explain what the suggestions for the content are.?', 'task': None, 'proxy_url': 'http://192.168.0.75:10809', 'agent_type': 'reasoner', 'max_iterations': 1, 'log_path': './data/output/log/paper_dataflow.md', 'log_type': 'markdown', 'log_step_name': 'feedback_agent', 'context': "Question: How to design an AIOS?\n\nAnswer: \n\nDesigning an AI Operating System (AIOS) involves several key strategies and methodologies, as identified through the analysis of various academic papers. Here are the main approaches and ideas proposed by researchers:\n\n1. **Modular Architecture**:\n   - **Component-Based Design**: Implement a modular architecture where different components (e.g., data processing, model training, inference) are decoupled. This allows for flexibility and scalability in the system [2304.01597v1].\n   - **Microservices**: Use microservices to manage different functionalities independently, enabling easier updates and maintenance [2304.01597v1].\n\n2. **Integration of Advanced AI Techniques**:\n   - **Knowledge Graphs**: Integrate knowledge graphs to enhance the system's ability to understand and process complex queries by providing contextual information [2304.01597v1].\n   - **Self-Supervised Learning**: Employ self-supervised learning techniques to improve the system's ability to learn from large amounts of unlabeled data, enhancing its language understanding and generation capabilities [2304.01597v1].\n\n3. **User-Centric Design**:\n   - **Natural Language Interface**: Develop a natural language interface that allows users to interact with the AIOS using conversational language, making it more accessible and user-friendly [2304.01597v1].\n   - **Personalization**: Implement personalization features that adapt to individual user preferences and behaviors, providing a more tailored experience [2304.01597v1].\n\n4. **Security and Privacy**:\n   - **Data Encryption**: Ensure that all user data is encrypted both in transit and at rest to protect against unauthorized access [2304.01597v1].\n   - **Privacy-Preserving Techniques**: Use techniques such as differential privacy to ensure that the system can learn from user data without compromising individual privacy [2304.01597v1].\n\n5. **Scalability and Performance**:\n   - **Distributed Computing**: Utilize distributed computing frameworks to handle large-scale data processing and model training, ensuring that the system can scale efficiently [2304.01597v1].\n   - **Optimization Algorithms**: Implement optimization algorithms to improve the performance and efficiency of the AI models, reducing latency and resource consumption [2304.01597v1].\n\n6. **Continuous Learning and Adaptation**:\n   - **Online Learning**: Incorporate online learning mechanisms that allow the system to continuously learn and adapt from new data, ensuring that it remains up-to-date with the latest information [2304.01597v1].\n   - **Feedback Loops**: Establish feedback loops where user interactions and feedback are used to refine and improve the system over time [2304.01597v1].\n\nBy integrating these strategies, an AIOS can be designed to be flexible, scalable, user-friendly, and secure, while continuously improving its capabilities through advanced AI techniques and user feedback."}
#
# inputs['context'] = writer_result.get('context')
# max_iterations,local_iterations = inputs.get('max_iterations'),writer_result.get('local_iterations', None)
#
# if local_iterations!=1 and  max_iterations >= local_iterations :
#     print('sasas')
# rag_data =  writer_result.get('rag_data',None)
# if 'agents' not in inputs.keys():
#     inputs['task'] = writer_result['task']
#     result = run_dspy_agent(agent_config=inputs)
# else:
#     result = run_crewai_agent(crewai_config=inputs)
# if inputs.get('max_iterations',None) is not None:
#
#     result = {'task':writer_result.get('task'),'suggestion':result,'context':writer_result.get('context'),'local_iterations':writer_result.get('local_iterations', None),'rag_data':rag_data}
# else:
#     result = {'task':writer_result.get('task'),'suggestion':result,'context':writer_result.get('context'),'rag_data':rag_data}
#
# print(result)
# log_result = {"5, " + inputs.get('log_step_name', "Step_one"): result['suggestion']}
# write_agent_log(log_type=inputs.get('log_type', None), log_file_path=inputs.get('log_path', None),
#                 data=log_result)